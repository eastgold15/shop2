import {
  type ClassDeclaration,
  type Node,
  type ObjectLiteralExpression,
  Scope,
  type SourceFile,
  SyntaxKind,
} from "ts-morph";

const GEN_TAG = "@generated";
const DOC_BLOCK = `/**\n * ğŸ¤– [Auto-Generated] Do not edit this tag to keep updates.\n * ${GEN_TAG}\n */`;

/**
 * ğŸ› ï¸ ç¡®ä¿ Import å­˜åœ¨
 */
export function ensureImport(
  file: SourceFile,
  moduleSpecifier: string,
  namedImports: string[]
) {
  let decl = file.getImportDeclaration(
    (d) => d.getModuleSpecifierValue() === moduleSpecifier
  );
  if (!decl) {
    decl = file.addImportDeclaration({ moduleSpecifier });
  }
  const existingNamed = decl.getNamedImports().map((n) => n.getName());
  for (const name of namedImports) {
    if (!existingNamed.includes(name)) {
      decl.addNamedImport(name);
    }
  }
}

/**
 * ğŸ› ï¸ æ™ºèƒ½æ›´æ–°å¯¹è±¡å±æ€§ (ç”¨äº Contract)
 */
export function upsertObjectProperty(
  objLiteral: ObjectLiteralExpression,
  key: string,
  value: string
) {
  const prop = objLiteral.getProperty(key);

  // 1. æ–°å¢
  if (!prop) {
    objLiteral.addPropertyAssignment({
      name: key,
      initializer: value,
      leadingTrivia: (w) => w.writeLine(DOC_BLOCK),
    });
    console.log(`     â• Property: ${key}`);
    return;
  }

  // 2. æ£€æŸ¥æ ‡è®°
  if (prop.isKind(SyntaxKind.PropertyAssignment)) {
    // 2.1 ç±»å‹æ–­è¨€ä¸º PropertyAssignmentï¼ˆç¡®ä¿ç±»å‹å®‰å…¨ï¼‰
    const propAssignment = prop;

    // 2.2 è·å–å±æ€§çš„åç§°èŠ‚ç‚¹ï¼ˆIdentifierï¼‰ï¼Œè¿™æ˜¯å¸¦æœ‰ JSDoc çš„èŠ‚ç‚¹
    const nameNode = propAssignment.getNameNode();
    if (!nameNode) {
      console.warn(
        `     âš ï¸ Property ${key} æ— æœ‰æ•ˆåç§°èŠ‚ç‚¹ï¼Œæ— æ³•æ£€æŸ¥è‡ªåŠ¨ç”Ÿæˆæ ‡è®°`
      );
      return;
    }

    const isGenerated = isAutoGenerated(nameNode);
    console.log(`     ğŸ” Property ${key} is auto generated: ${isGenerated}`);

    if (isGenerated) {
      if (prop.getInitializer()?.getText() !== value) {
        prop.setInitializer(value);
        console.log(`     ğŸ”„ Updated: ${key}`);
      }
    } else {
      console.log(`     ğŸ›¡ï¸ Skipped (Custom): ${key}`);
    }
  }
}

/**
 * ğŸ› ï¸ æ™ºèƒ½æ›´æ–°ç±»æ–¹æ³• (ç”¨äº Service/Controller)
 */
export function upsertMethod(
  classDec: ClassDeclaration,
  name: string,
  body: string,
  params: { name: string; type: string }[] = [],
  returnType?: string
) {
  const method = classDec.getMethod(name);

  // 1. æ–°å¢
  if (!method) {
    const m = classDec.addMethod({
      name,
      parameters: params,
      returnType,
      isAsync: true,
      scope: Scope.Public,
      statements: body,
    });
    m.addJsDoc(DOC_BLOCK);
    console.log(`     â• Method: ${name}`);
    return;
  }

  // 2. æ£€æŸ¥æ ‡è®°
  const isGenerated = method
    .getJsDocs()
    .some((d) => d.getInnerText().includes(GEN_TAG));

  if (isGenerated) {
    method.setBodyText(body);
    // æ›´æ–°å‚æ•°ç±»å‹ä»¥é˜² Schema å˜æ›´
    method.getParameters().forEach((p) => p.remove());
    params.forEach((p) => method.addParameter(p));
    if (returnType) method.setReturnType(returnType);
    console.log(`     ğŸ”„ Updated: ${name}`);
  } else {
    console.log(`     ğŸ›¡ï¸ Skipped (Custom): ${name}`);
  }
}
/**
 * å·¥å…·æ–¹æ³• 1ï¼šæœ€æ–°ç‰ˆ ts-morph å…¼å®¹ - æå–èŠ‚ç‚¹å‰ç½® JSDoc çº¯æ–‡æœ¬
 * @param node ä»»æ„èŠ‚ç‚¹ï¼ˆIdentifier/PropertyName ç­‰ï¼‰
 * @returns çº¯å‡€çš„ JSDoc æ–‡æœ¬
 */
function getLeadingJSDocText(node: Node): string {
  // 1. è·å–èŠ‚ç‚¹æ‰€åœ¨æºæ–‡ä»¶çš„å®Œæ•´æ–‡æœ¬
  const fullText = node.getSourceFile().getFullText();

  // 2. è·å–èŠ‚ç‚¹çš„èµ·å§‹ä½ç½®ï¼ˆåç§»é‡ï¼‰
  const nodeStart = node.getPos();

  // 3. æˆªå–èŠ‚ç‚¹å‰æ–¹çš„æ‰€æœ‰æ–‡æœ¬ï¼ˆå³å‰ç½® trivia å†…å®¹ï¼‰
  const leadingText = fullText.slice(0, nodeStart);

  // 4. æ­£åˆ™åŒ¹é…æœ€åä¸€ä¸ª JSDoc æ³¨é‡Šï¼ˆ/** ... */ æ ¼å¼ï¼Œç¡®ä¿æ˜¯èŠ‚ç‚¹ç›´æ¥å‰ç½®çš„æ³¨é‡Šï¼‰
  const jsDocMatches = leadingText.match(/\/\*\*[\s\S]*?\*\//g);
  if (!jsDocMatches || jsDocMatches.length === 0) return "";

  // 5. å–æœ€åä¸€ä¸ªåŒ¹é…ç»“æœï¼ˆæœ€é è¿‘èŠ‚ç‚¹çš„ JSDocï¼‰
  const lastJsDoc = jsDocMatches.at(-1);

  // 6. å»é™¤æ³¨é‡Šæ ‡è®°ï¼Œæå–çº¯æ–‡æœ¬
  return lastJsDoc
    ? lastJsDoc
        .replace(/^\/\*\*+/, "")
        .replace(/\*+\/$/, "")
        .replace(/^\s*\*\s*/gm, "")
        .trim()
    : "";
}

/**
 * å·¥å…·æ–¹æ³• 2ï¼šåˆ¤æ–­èŠ‚ç‚¹æ˜¯å¦ä¸ºè‡ªåŠ¨ç”Ÿæˆï¼ˆå‰ç½® JSDoc åŒ…å« GEN_TAGï¼‰
 * @param node ä»»æ„èŠ‚ç‚¹ï¼ˆIdentifier/PropertyName ç­‰ï¼‰
 * @returns æ˜¯å¦ä¸ºè‡ªåŠ¨ç”Ÿæˆ
 */
function isAutoGenerated(node: Node): boolean {
  const jsDocText = getLeadingJSDocText(node);
  // ç²¾å‡†åŒ¹é… @auto-gen æ ‡ç­¾ï¼Œé¿å…è¯¯åˆ¤
  return /@auto-gen\b/.test(jsDocText);
}
