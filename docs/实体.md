这项系统架构采用了经典的 **RBAC（基于角色的访问控制）** 结合 **多租户（SaaS）** 和 **数据范围（Data Scope）** 的设计。



### 2. 你的具体疑问解答

#### Q1: 多个租户，如何区分部门？

**答案：通过 `tenant_id` 物理隔离，通过 `category` 逻辑区分。**

在你的代码中，所有核心表（包括 `sys_dept`）都有 `tenant_id`。

* **硬隔离**：`tenant_id` 决定了这是哪家“出口商/集团”的数据。A公司的员工绝对查不到 B公司的部门。
* **部门性质**：在 `sys_dept` 表中，你定义了 `deptCategoryEnum`：
* `headquarters` (总部)：通常是出口商核心管理层。
* `factory` (工厂)：实体工厂，挂在租户名下。
* `office` (办事处)：其他分支机构。



#### Q2: 如何做到工厂归出口商管？

**答案：工厂本质上是出口商（租户）下的一个“部门”。**

* **数据库层面**：
工厂的数据在 `sys_dept` 表里，它的 `tenant_id` 指向出口商的 ID。
* **业务层面**：
因为 `sys_dept` 还有一个 `parent_id` 字段，你可以建立树形结构。
* **场景 A (扁平管理)**：总部、工厂A、工厂B 都是顶级部门（ParentID 为空），平级，都属于同一个 Tenant。
* **场景 B (垂直管理)**：工厂A 的 `parent_id` 指向 总部。



#### Q3: 业务员在出口商下和在工厂下，查询的业务有何不同？

**答案：这完全由 `sys_role` 表中的 `data_scope`（数据范围）决定。**

这是你系统最核心的权限逻辑，代码里定义的枚举 `dataScopeEnum` 解释了一切：

| 角色位置 | 分配的数据权限 (Data Scope) | 实际 SQL 查询效果 (WHERE 条件) | 看到的内容 |
| --- | --- | --- | --- |
| **总部管理员** | `all` (全部数据) | `WHERE tenant_id = '当前租户'` | 看到总部 + 所有工厂的所有数据 |
| **总部经理** | `dept_and_child` (本部门及下级) | `WHERE tenant_id = '...' AND dept_id IN (总部ID, 工厂A, 工厂B...)` | 看到总部和归属总部的工厂数据 |
| **工厂跟单员** | `dept_only` (本部门) | `WHERE tenant_id = '...' AND dept_id = '工厂A_ID'` | **只能看到自己工厂的数据**，看不到总部的，也看不到工厂B的 |
| **普通业务员** | `self` (仅本人) | `WHERE tenant_id = '...' AND created_by = '用户ID'` | 无论在总部还是工厂，**只能看到自己创建的单据** |

---

### 3. 代码中的关键“胶水”

你设计了一个非常聪明的辅助对象 `tenantCols`，它被 Spread (`...`) 到了所有业务表（Product, SKU, Inquiry 等）中。

```typescript
// 你的代码片段
export const tenantCols = {
  // 1. 硬隔离：属于哪个大集团/出口商
  tenantId: p.uuid("tenant_id").references(() => tenantTable.id),

  // 2. 软归属：数据产自哪个部门（是工厂生产的？还是总部创建的？）
  // 这就是实现 "工厂只能看工厂数据" 的关键字段
  deptId: p.uuid("dept_id").references(() => departmentTable.id),

  // 3. 数据所有权：具体是谁做的
  createdBy: p.uuid("created_by").references(() => userTable.id),
  ...
};

```

**实际查询场景模拟：**

假设有一个 **"查询订单列表"** 的 API。

1. **用户 A (工厂业务员)** 登录。
* 系统识别：User A, Tenant: `T1`, Dept: `Factory_A`, Role: `Staff (DataScope: dept_only)`.
* **生成的 SQL**:
```sql
SELECT * FROM inquiry 
WHERE tenant_id = 'T1' 
AND dept_id = 'Factory_A'; -- 只能看到本工厂的询盘

```




2. **用户 B (总部老板)** 登录。
* 系统识别：User B, Tenant: `T1`, Dept: `Headquarters`, Role: `Admin (DataScope: all)`.
* **生成的 SQL**:
```sql
SELECT * FROM inquiry 
WHERE tenant_id = 'T1'; -- 能看到 T1 下所有部门（包括所有工厂）的询盘

```


### 4. 站点 (Site) 的特殊逻辑

你还有一个 `siteTable`，它有一个巧妙的字段 `boundDeptId`：

* **集团官网 (`site_type = group`)**：`boundDeptId` 可能为空或指向总部。展示 Tenant 下所有商品。
* **工厂独立站 (`site_type = factory`)**：`boundDeptId` 指向具体工厂。
* 当前端渲染这个站点时，只会查询 `WHERE dept_id = boundDeptId` 的商品。
* 这就实现了：**同一个数据库，既能通过集团站卖所有货，又能给每个工厂开独立的展示站，互不干扰。**



### 总结

你的系统结构非常清晰：

1. **Tenant** 负责切分不同的公司（客户）。
2. **Dept** 负责切分公司内部的组织（总部 vs 工厂）。
3. **Role + DataScope** 负责切分人的视野（能看多少数据）。
4. **tenantCols** 确保每一条业务数据都带上了“身份证”（属于哪家公司，属于哪个部门）。