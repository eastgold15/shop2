这项系统架构采用了经典的 **RBAC（基于角色的访问控制）** 结合 **多租户（SaaS）** 和 **数据范围（Data Scope）** 的设计。

一个典型的 B2B 多租户 SaaS 系统，它不仅仅是简单的商城，而是一个“企业-工厂-站点”的三层架构，支持总部管控与分支机构（工厂）独立运营的复杂场景。

1. 核心 RBAC 与 组织架构实体
系统的核心权限模型由 租户(Tenant) > 部门(Dept) > 用户(User) > 角色(Role) 构成。
关键实体关系：
sys_tenant (租户): 最高物理隔离层。代表一个完整的企业客户。

sys_dept (部门): 组织核心。通过 parentId 实现树形结构。category 区分了“总部”与“工厂”。

sys_user (用户): 同时关联 tenantId（归属企业）和 deptId（归属具体部门或工厂）。

sys_role (角色): 引入了 data_scope（数据权限范围）。这比普通 RBAC 更进一层，它决定了用户能看到“全公司”、“本部门”还是“仅个人”的数据。



2. 业务架构：核心资产与站点的解耦
你设计的 standardCols 与 siteScopedCols 是架构中的神来之笔。它将**资产（Product/SKU）与表现层（Site）**完美解耦。

商品与站点的关系
资产库 (Standard Assets): product 和 sku 仅绑定到 tenantId 和 deptId。这意味着商品是属于企业的“资产库存”。

站点映射 (Site Mapping): site_product 表充当了“上架”逻辑。

总部站 (Group Site): 可以将全租户下不同工厂（Dept）的商品全部关联进来。

工厂站 (Factory Site): 只关联该工厂（Dept）自己生产的商品。

内容隔离 (Site Scoped): 广告（Ad）、装修（HeroCard）、配置（SiteConfig）通过 siteScopedCols 强绑定 siteId，确保不同站点间的前端展示完全独立。




客户端与管理端的运行逻辑
客户端 (Client-Side / Storefront)
逻辑控制: 客户端通过域名（Domain）识别 siteTable 中的记录。

数据流: * 若 siteType 为 group，则查询所有关联至该租户且在 site_product 中的商品。

若 siteType 为 factory，则通过 boundDeptId 过滤，只展示特定工厂的商品。

交互: 产生的 inquiry（询盘）带上 siteId，这样管理员就知道客户是从哪个入口进来的。

管理端 (Admin Panel)
用户登录: 获取 user.tenantId。系统通过该 ID 进行全局拦截，确保用户无法越权访问其他租户的数据。

站点切换: * 超级管理员 (Tenant Admin): 可以看到租户下所有的 Site。在管理端顶部有一个“站点切换器”，切换后，API 请求头携带 X-Site-Id。

工厂管理员: 只能看到归属于自己 deptId 的站点。

数据隔离: * 查询 product 时，根据 role.data_scope 自动注入 SQL 过滤条件（例如：WHERE dept_id = user.deptId）。


. 项目俯瞰图 (Summary Table)层级负责内容核心隔离键租户层 (Tenant)企业资料、订阅计划、全局用户库tenantId组织层 (Dept)工厂管理、部门职能、数据权限边界deptId / parentId资产层 (Resource)SPU、SKU、媒体素材、客户资料tenantId + deptId展示层 (Site)域名、SEO、站点分类、装修组件siteId交互层 (Action)询盘、报价单、访问日志siteId + createdBy

### 2. 你的具体疑问解答

#### Q1: 多个租户，如何区分部门？

**答案：通过 `tenant_id` 物理隔离，通过 `category` 逻辑区分。**

在你的代码中，所有核心表（包括 `sys_dept`）都有 `tenant_id`。

* **硬隔离**：`tenant_id` 决定了这是哪家“出口商/集团”的数据。A公司的员工绝对查不到 B公司的部门。
* **部门性质**：在 `sys_dept` 表中，你定义了 `deptCategoryEnum`：
* `headquarters` (总部)：通常是出口商核心管理层。
* `factory` (工厂)：实体工厂，挂在租户名下。
* `office` (办事处)：其他分支机构。



#### Q2: 如何做到工厂归出口商管？

**答案：工厂本质上是出口商（租户）下的一个“部门”。**

* **数据库层面**：
工厂的数据在 `sys_dept` 表里，它的 `tenant_id` 指向出口商的 ID。
* **业务层面**：
因为 `sys_dept` 还有一个 `parent_id` 字段，你可以建立树形结构。
* **场景 A (扁平管理)**：总部、工厂A、工厂B 都是顶级部门（ParentID 为空），平级，都属于同一个 Tenant。
* **场景 B (垂直管理)**：工厂A 的 `parent_id` 指向 总部。



#### Q3: 业务员在出口商下和在工厂下，查询的业务有何不同？

**答案：这完全由 `sys_role` 表中的 `data_scope`（数据范围）决定。**

这是你系统最核心的权限逻辑，代码里定义的枚举 `dataScopeEnum` 解释了一切：

| 角色位置 | 分配的数据权限 (Data Scope) | 实际 SQL 查询效果 (WHERE 条件) | 看到的内容 |
| --- | --- | --- | --- |
| **总部管理员** | `all` (全部数据) | `WHERE tenant_id = '当前租户'` | 看到总部 + 所有工厂的所有数据 |
| **总部经理** | `dept_and_child` (本部门及下级) | `WHERE tenant_id = '...' AND dept_id IN (总部ID, 工厂A, 工厂B...)` | 看到总部和归属总部的工厂数据 |
| **工厂跟单员** | `dept_only` (本部门) | `WHERE tenant_id = '...' AND dept_id = '工厂A_ID'` | **只能看到自己工厂的数据**，看不到总部的，也看不到工厂B的 |
| **普通业务员** | `self` (仅本人) | `WHERE tenant_id = '...' AND created_by = '用户ID'` | 无论在总部还是工厂，**只能看到自己创建的单据** |

---

### 3. 代码中的关键“胶水”

你设计了一个非常聪明的辅助对象 `tenantCols`，它被 Spread (`...`) 到了所有业务表（Product, SKU, Inquiry 等）中。

```typescript
// 你的代码片段
export const tenantCols = {
  // 1. 硬隔离：属于哪个大集团/出口商
  tenantId: p.uuid("tenant_id").references(() => tenantTable.id),

  // 2. 软归属：数据产自哪个部门（是工厂生产的？还是总部创建的？）
  // 这就是实现 "工厂只能看工厂数据" 的关键字段
  deptId: p.uuid("dept_id").references(() => departmentTable.id),

  // 3. 数据所有权：具体是谁做的
  createdBy: p.uuid("created_by").references(() => userTable.id),
  ...
};

```

**实际查询场景模拟：**

假设有一个 **"查询订单列表"** 的 API。

1. **用户 A (工厂业务员)** 登录。
* 系统识别：User A, Tenant: `T1`, Dept: `Factory_A`, Role: `Staff (DataScope: dept_only)`.
* **生成的 SQL**:
```sql
SELECT * FROM inquiry 
WHERE tenant_id = 'T1' 
AND dept_id = 'Factory_A'; -- 只能看到本工厂的询盘

```




2. **用户 B (总部老板)** 登录。
* 系统识别：User B, Tenant: `T1`, Dept: `Headquarters`, Role: `Admin (DataScope: all)`.
* **生成的 SQL**:
```sql
SELECT * FROM inquiry 
WHERE tenant_id = 'T1'; -- 能看到 T1 下所有部门（包括所有工厂）的询盘

```


### 4. 站点 (Site) 的特殊逻辑

你还有一个 `siteTable`，它有一个巧妙的字段 `boundDeptId`：

* **集团官网 (`site_type = group`)**：`boundDeptId` 可能为空或指向总部。展示 Tenant 下所有商品。
* **工厂独立站 (`site_type = factory`)**：`boundDeptId` 指向具体工厂。
* 当前端渲染这个站点时，只会查询 `WHERE dept_id = boundDeptId` 的商品。
* 这就实现了：**同一个数据库，既能通过集团站卖所有货，又能给每个工厂开独立的展示站，互不干扰。**



### 总结

你的系统结构非常清晰：

1. **Tenant** 负责切分不同的公司（客户）。
2. **Dept** 负责切分公司内部的组织（总部 vs 工厂）。
3. **Role + DataScope** 负责切分人的视野（能看多少数据）。
4. **tenantCols** 确保每一条业务数据都带上了“身份证”（属于哪家公司，属于哪个部门）。




作为项目架构师，我将从**核心模型逻辑、多租户/多站点架构、以及权限隔离机制**三个维度为你深度解析此设计。

该 Drizzle Schema 设计了一个典型的 **B2B 多租户 SaaS 系统**，它不仅仅是简单的商城，而是一个“企业-工厂-站点”的三层架构，支持总部管控与分支机构（工厂）独立运营的复杂场景。

---

## 1. 核心 RBAC 与 组织架构实体

系统的核心权限模型由 **租户(Tenant) > 部门(Dept) > 用户(User) > 角色(Role)** 构成。

### 关键实体关系：

* **sys_tenant (租户):** 最高物理隔离层。代表一个完整的企业客户。
* **sys_dept (部门):** 组织核心。通过 `parentId` 实现树形结构。`category` 区分了“总部”与“工厂”。
* **sys_user (用户):** 同时关联 `tenantId`（归属企业）和 `deptId`（归属具体部门或工厂）。
* **sys_role (角色):** 引入了 `data_scope`（数据权限范围）。这比普通 RBAC 更进一层，它决定了用户能看到“全公司”、“本部门”还是“仅个人”的数据。

---

## 2. 业务架构：核心资产与站点的解耦

你设计的 `standardCols` 与 `siteScopedCols` 是架构中的神来之笔。它将**资产（Product/SKU）**与**表现层（Site）**完美解耦。

### 商品与站点的关系

1. **资产库 (Standard Assets):** `product` 和 `sku` 仅绑定到 `tenantId` 和 `deptId`。这意味着商品是属于企业的“资产库存”。
2. **站点映射 (Site Mapping):** `site_product` 表充当了“上架”逻辑。
* **总部站 (Group Site):** 可以将全租户下不同工厂（Dept）的商品全部关联进来。
* **工厂站 (Factory Site):** 只关联该工厂（Dept）自己生产的商品。


3. **内容隔离 (Site Scoped):** 广告（Ad）、装修（HeroCard）、配置（SiteConfig）通过 `siteScopedCols` 强绑定 `siteId`，确保不同站点间的前端展示完全独立。

---

## 3. 客户端与管理端的运行逻辑

### 客户端 (Client-Side / Storefront)

* **逻辑控制:** 客户端通过域名（Domain）识别 `siteTable` 中的记录。
* **数据流:** * 若 `siteType` 为 `group`，则查询所有关联至该租户且在 `site_product` 中的商品。
* 若 `siteType` 为 `factory`，则通过 `boundDeptId` 过滤，只展示特定工厂的商品。


* **交互:** 产生的 `inquiry`（询盘）带上 `siteId`，这样管理员就知道客户是从哪个入口进来的。

### 管理端 (Admin Panel)

* **用户登录:** 获取 `user.tenantId`。系统通过该 ID 进行全局拦截，确保用户无法越权访问其他租户的数据。
* **站点切换:** * **超级管理员 (Tenant Admin):** 可以看到租户下所有的 Site。在管理端顶部有一个“站点切换器”，切换后，API 请求头携带 `X-Site-Id`。
* **工厂管理员:** 只能看到归属于自己 `deptId` 的站点。


* **数据隔离:** * 查询 `product` 时，根据 `role.data_scope` 自动注入 SQL 过滤条件（例如：`WHERE dept_id = user.deptId`）。

---

## 4. 架构师视角的优化建议

### A. 站点与部门的约束

在 `siteTable` 中，建议增加逻辑校验：如果 `siteType` 是 `factory`，则 `boundDeptId` 必须不为空。

### B. 询盘(Inquiry) 分发逻辑

目前的 `inquiryTable` 绑定了 `siteId`。

* **建议:** 增加一个 `assigned_to` (用户ID) 字段。
* **逻辑:** 总站收到的询盘，由总部管理员手动分发给对应工厂的销售；工厂站收到的询盘，自动分配给该部门下的默认销售。

### C. 规格模板(Template) 的多租户化

目前的 `templateTable` 缺少 `tenantId`。

* **建议:** 为 `templateTable` 加上 `tenantId`。否则，租户 A 定义的“衣服尺码模板”可能会被租户 B 看到或误用。

### D. 性能优化：站点商品视图

由于商品是多站点复用的，查询时会涉及多表 Join (`product` -> `site_product` -> `sku`)。

* **建议:** 对于展示频率极高的客户端页面，可以考虑针对 `site_product` 建立物化视图，或者在 `site_product` 中冗余存储一些 SPU 的核心字段（如主图、标题）。

---

## 5. 项目俯瞰图 (Summary Table)

| 层级 | 负责内容 | 核心隔离键 |
| --- | --- | --- |
| **租户层 (Tenant)** | 企业资料、订阅计划、全局用户库 | `tenantId` |
| **组织层 (Dept)** | 工厂管理、部门职能、数据权限边界 | `deptId` / `parentId` |
| **资产层 (Resource)** | SPU、SKU、媒体素材、客户资料 | `tenantId` + `deptId` |
| **展示层 (Site)** | 域名、SEO、站点分类、装修组件 | `siteId` |
| **交互层 (Action)** | 询盘、报价单、访问日志 | `siteId` + `createdBy` |

---

## 权限系统详细设计

### 核心权限模型

本系统的权限控制基于 **User → Site (Context) → Role → Permissions** 的链路：

1. **用户 (User)** - 基础身份标识
2. **站点上下文 (Site Context)** - 当前操作的站点环境
3. **角色 (Role)** - 在特定站点上的角色定义
4. **权限 (Permissions)** - 具体的操作权限集合

### 标准列模式 (Standard Columns Pattern)

系统中定义了两种核心列模式，用于实现多租户和数据隔离：

#### 1. 租户列 (tenantCols)

应用于所有业务表，实现租户级隔离：

```typescript
export const tenantCols = {
  // 租户ID - 物理隔离
  tenantId: p.uuid("tenant_id").references(() => tenantTable.id),

  // 部门ID - 组织归属
  deptId: p.uuid("dept_id").references(() => departmentTable.id),

  // 创建者 - 数据所有权
  createdBy: p.uuid("created_by").references(() => userTable.id),

  // 更新者
  updatedBy: p.uuid("updated_by").references(() => userTable.id),

  // 时间戳
  createdAt: p.timestamp("created_at").defaultNow(),
  updatedAt: p.timestamp("updated_at").defaultNow(),
};
```

**应用表**：product、sku、inquiry、quotation、customer 等所有业务表

#### 2. 站点作用域列 (siteScopedCols)

应用于站点特定的表，实现站点级隔离：

```typescript
export const siteScopedCols = {
  // 站点ID - 强绑定到特定站点
  siteId: p.uuid("site_id").references(() => siteTable.id).notNull(),

  // 继承租户列
  ...tenantCols,
};
```

**应用表**：site_category、hero_card、ad、site_config 等站点配置表

### 数据权限范围 (Data Scope)

系统通过 `data_scope` 字段实现细粒度的数据访问控制：

| 数据权限范围 | SQL WHERE 条件示例 | 应用场景 |
| --- | --- | --- |
| `all` | `WHERE tenant_id = ?` | 超级管理员、出口商老板 |
| `dept_and_child` | `WHERE dept_id IN (?, ?, ...)` | 总部经理（包含子部门） |
| `dept_only` | `WHERE dept_id = ?` | 工厂管理员 |
| `self` | `WHERE created_by = ?` | 普通业务员 |

### 权限矩阵示例

#### 站点管理权限

| 角色 | 创建工厂站 | 创建出口商站 | 管理所有站点 | 管理本部门站点 |
| --- | --- | --- | --- | --- |
| 超级管理员 | ✅ | ✅ | ✅ | ✅ |
| 出口商管理员 | ✅ | ❌ | ✅ | ✅ |
| 工厂管理员 | ❌ | ❌ | ✅ | ❌ |
| 业务员 | ❌ | ❌ | ❌ | ❌ |

#### 商品数据访问权限

| 角色 | 全租户商品 | 本部门商品 | 个人创建商品 |
| --- | --- | --- | --- |
| 超级管理员 | ✅ | ✅ | ✅ |
| 出口商管理员 | ✅ | ✅ | ✅ |
| 工厂管理员 | ❌ | ✅ | ✅ |
| 业务员 | ❌ | ❌ | ✅ |

### 权限检查流程

```typescript
// 1. 用户登录，获取基本信息
const user = await getUser();

// 2. 切换到特定站点上下文
const siteContext = await switchSite(siteId);

// 3. 获取用户在该站点的角色
const role = await getUserRoleInSite(user.id, siteId);

// 4. 根据角色的 data_scope 构建查询条件
const dataScope = role.dataScope;
const whereClause = buildWhereClause(user, dataScope);

// 5. 执行查询
const data = await db.query.productTable.findMany({
  where: whereClause
});
```

### 站点上下文切换

系统支持动态站点切换，切换时：

1. 验证用户在目标站点的访问权限
2. 更新 session 中的当前站点信息
3. 重新加载用户在该站点的角色和权限
4. 刷新前端界面，根据新权限显示/隐藏功能

详见 [[multi-site-architecture.md]] 中的站点切换流程。

